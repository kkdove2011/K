/* KProcessServiceStub.h
   Generated by gSOAP 2.8.91 for .\KProcessService.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_WS1	"http://service.process.k"
#define SOAP_NAMESPACE_OF_WS2	"http://xml.apache.org/xml-soap"

#ifndef KProcessServiceStub_H
#define KProcessServiceStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20891
# error "GSOAP VERSION 20891 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* .\KProcessService.h:152 */
class xsd__base64Binary;	/* .\KProcessService.h:159 */
class xsd__base64Binary__;	/* .\KProcessService.h:168 */
class xsd__boolean_;	/* .\KProcessService.h:175 */
class xsd__string_;	/* .\KProcessService.h:182 */
class WS1__GetFileResp;	/* .\KProcessService.h:195 */
class WS1__Property;	/* .\KProcessService.h:197 */
class WS1__ArrayOfProperty;	/* .\KProcessService.h:199 */
class WS1__CreateItemInfo;	/* .\KProcessService.h:201 */
class WS1__ArrayOf_USCORExsd_USCOREstring;	/* .\KProcessService.h:203 */
class WS1__ArrayOf_USCORExsd_USCOREboolean;	/* .\KProcessService.h:205 */
class WS1__CreateItemResp;	/* .\KProcessService.h:207 */
class _WS1__getFile;	/* .\KProcessService.h:209 */
class _WS1__getFileResponse;	/* .\KProcessService.h:211 */
class _WS1__importData;	/* .\KProcessService.h:213 */
class _WS1__importDataResponse;	/* .\KProcessService.h:215 */
class _WS1__hello;	/* .\KProcessService.h:217 */
class _WS1__helloResponse;	/* .\KProcessService.h:219 */
class _WS1__createItems;	/* .\KProcessService.h:221 */
class _WS1__createItemsResponse;	/* .\KProcessService.h:223 */
class WS2__mapItem;	/* .\KProcessService.h:225 */
class WS2__Map;	/* .\KProcessService.h:227 */
struct __WS1__getFile;	/* .\KProcessService.h:807 */
struct __WS1__importData;	/* .\KProcessService.h:874 */
struct __WS1__hello;	/* .\KProcessService.h:941 */
struct __WS1__createItems;	/* .\KProcessService.h:1008 */

/* .\KProcessService.h:152 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 KProcessService_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:159 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 KProcessService_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:168 */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (14)
/* Type xsd__base64Binary__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 KProcessService_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:175 */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (15)
/* Type xsd__boolean_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 KProcessService_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:182 */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (17)
/* Type xsd__string_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:string': */
class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 KProcessService_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:195 */
#ifndef SOAP_TYPE_WS1__GetFileResp
#define SOAP_TYPE_WS1__GetFileResp (19)
/* Type WS1__GetFileResp is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:GetFileResp': */
class SOAP_CMAC WS1__GetFileResp : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'WS1:fileData' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *fileData;
        /// Required nillable (xsi:nil when NULL) element 'WS1:fileName' of XML schema type 'xsd:string'
        std::string *fileName;
        /// Required nillable (xsi:nil when NULL) element 'WS1:message' of XML schema type 'xsd:string'
        std::string *message;
        /// Required element 'WS1:success' of XML schema type 'xsd:boolean'
        bool success;
      public:
        /// Return unique type id SOAP_TYPE_WS1__GetFileResp
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__GetFileResp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__GetFileResp, default initialized and not managed by a soap context
        virtual WS1__GetFileResp *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__GetFileResp); }
      public:
        /// Constructor with default initializations
        WS1__GetFileResp() : fileData(), fileName(), message(), success() { }
        virtual ~WS1__GetFileResp() { }
        /// Friend allocator used by soap_new_WS1__GetFileResp(struct soap*, int)
        friend SOAP_FMAC1 WS1__GetFileResp * SOAP_FMAC2 KProcessService_instantiate_WS1__GetFileResp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:197 */
#ifndef SOAP_TYPE_WS1__Property
#define SOAP_TYPE_WS1__Property (20)
/* Type WS1__Property is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:Property': */
class SOAP_CMAC WS1__Property : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'WS1:propertyName' of XML schema type 'xsd:string'
        std::string *propertyName;
        /// Required nillable (xsi:nil when NULL) element 'WS1:propertyValue' of XML schema type 'xsd:string'
        std::string *propertyValue;
      public:
        /// Return unique type id SOAP_TYPE_WS1__Property
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__Property; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__Property, default initialized and not managed by a soap context
        virtual WS1__Property *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__Property); }
      public:
        /// Constructor with default initializations
        WS1__Property() : propertyName(), propertyValue() { }
        virtual ~WS1__Property() { }
        /// Friend allocator used by soap_new_WS1__Property(struct soap*, int)
        friend SOAP_FMAC1 WS1__Property * SOAP_FMAC2 KProcessService_instantiate_WS1__Property(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:199 */
#ifndef SOAP_TYPE_WS1__ArrayOfProperty
#define SOAP_TYPE_WS1__ArrayOfProperty (21)
/* Type WS1__ArrayOfProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:ArrayOfProperty': */
class SOAP_CMAC WS1__ArrayOfProperty : public xsd__anyType {
      public:
        /// Optional element 'WS1:item' of XML schema type 'WS1:Property'
        std::vector<WS1__Property *> item;
      public:
        /// Return unique type id SOAP_TYPE_WS1__ArrayOfProperty
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__ArrayOfProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__ArrayOfProperty, default initialized and not managed by a soap context
        virtual WS1__ArrayOfProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__ArrayOfProperty); }
      public:
        /// Constructor with default initializations
        WS1__ArrayOfProperty() : item() { }
        virtual ~WS1__ArrayOfProperty() { }
        /// Friend allocator used by soap_new_WS1__ArrayOfProperty(struct soap*, int)
        friend SOAP_FMAC1 WS1__ArrayOfProperty * SOAP_FMAC2 KProcessService_instantiate_WS1__ArrayOfProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:201 */
#ifndef SOAP_TYPE_WS1__CreateItemInfo
#define SOAP_TYPE_WS1__CreateItemInfo (22)
/* Type WS1__CreateItemInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:CreateItemInfo': */
class SOAP_CMAC WS1__CreateItemInfo : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemMasterProperties' of XML schema type 'WS1:ArrayOfProperty'
        WS1__ArrayOfProperty *itemMasterProperties;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemMasterProps' of XML schema type 'WS2:Map'
        WS2__Map *itemMasterProps;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemMasterProps2' of XML schema type 'WS2:Map'
        WS2__Map *itemMasterProps2;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemProperties' of XML schema type 'WS1:ArrayOfProperty'
        WS1__ArrayOfProperty *itemProperties;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemProps' of XML schema type 'WS2:Map'
        WS2__Map *itemProps;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemProps2' of XML schema type 'WS2:Map'
        WS2__Map *itemProps2;
        /// Required nillable (xsi:nil when NULL) element 'WS1:itemType' of XML schema type 'xsd:string'
        std::string *itemType;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revMasterProperties' of XML schema type 'WS1:ArrayOfProperty'
        WS1__ArrayOfProperty *revMasterProperties;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revMasterProps' of XML schema type 'WS2:Map'
        WS2__Map *revMasterProps;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revMasterProps2' of XML schema type 'WS2:Map'
        WS2__Map *revMasterProps2;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revProperties' of XML schema type 'WS1:ArrayOfProperty'
        WS1__ArrayOfProperty *revProperties;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revProps' of XML schema type 'WS2:Map'
        WS2__Map *revProps;
        /// Required nillable (xsi:nil when NULL) element 'WS1:revProps2' of XML schema type 'WS2:Map'
        WS2__Map *revProps2;
      public:
        /// Return unique type id SOAP_TYPE_WS1__CreateItemInfo
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__CreateItemInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__CreateItemInfo, default initialized and not managed by a soap context
        virtual WS1__CreateItemInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__CreateItemInfo); }
      public:
        /// Constructor with default initializations
        WS1__CreateItemInfo() : itemMasterProperties(), itemMasterProps(), itemMasterProps2(), itemProperties(), itemProps(), itemProps2(), itemType(), revMasterProperties(), revMasterProps(), revMasterProps2(), revProperties(), revProps(), revProps2() { }
        virtual ~WS1__CreateItemInfo() { }
        /// Friend allocator used by soap_new_WS1__CreateItemInfo(struct soap*, int)
        friend SOAP_FMAC1 WS1__CreateItemInfo * SOAP_FMAC2 KProcessService_instantiate_WS1__CreateItemInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:203 */
#ifndef SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring
#define SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring (23)
/* Type WS1__ArrayOf_USCORExsd_USCOREstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:ArrayOf_xsd_string': */
class SOAP_CMAC WS1__ArrayOf_USCORExsd_USCOREstring : public xsd__anyType {
      public:
        /// Optional element 'WS1:item' of XML schema type 'xsd:string'
        std::vector<std::string> item;
      public:
        /// Return unique type id SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__ArrayOf_USCORExsd_USCOREstring, default initialized and not managed by a soap context
        virtual WS1__ArrayOf_USCORExsd_USCOREstring *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__ArrayOf_USCORExsd_USCOREstring); }
      public:
        /// Constructor with default initializations
        WS1__ArrayOf_USCORExsd_USCOREstring() : item() { }
        virtual ~WS1__ArrayOf_USCORExsd_USCOREstring() { }
        /// Friend allocator used by soap_new_WS1__ArrayOf_USCORExsd_USCOREstring(struct soap*, int)
        friend SOAP_FMAC1 WS1__ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC2 KProcessService_instantiate_WS1__ArrayOf_USCORExsd_USCOREstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:205 */
#ifndef SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean
#define SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean (24)
/* Type WS1__ArrayOf_USCORExsd_USCOREboolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:ArrayOf_xsd_boolean': */
class SOAP_CMAC WS1__ArrayOf_USCORExsd_USCOREboolean : public xsd__anyType {
      public:
        /// Optional element 'WS1:item' of XML schema type 'xsd:boolean'
        std::vector<bool> item;
      public:
        /// Return unique type id SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__ArrayOf_USCORExsd_USCOREboolean, default initialized and not managed by a soap context
        virtual WS1__ArrayOf_USCORExsd_USCOREboolean *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__ArrayOf_USCORExsd_USCOREboolean); }
      public:
        /// Constructor with default initializations
        WS1__ArrayOf_USCORExsd_USCOREboolean() : item() { }
        virtual ~WS1__ArrayOf_USCORExsd_USCOREboolean() { }
        /// Friend allocator used by soap_new_WS1__ArrayOf_USCORExsd_USCOREboolean(struct soap*, int)
        friend SOAP_FMAC1 WS1__ArrayOf_USCORExsd_USCOREboolean * SOAP_FMAC2 KProcessService_instantiate_WS1__ArrayOf_USCORExsd_USCOREboolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:207 */
#ifndef SOAP_TYPE_WS1__CreateItemResp
#define SOAP_TYPE_WS1__CreateItemResp (25)
/* Type WS1__CreateItemResp is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS1:CreateItemResp': */
class SOAP_CMAC WS1__CreateItemResp : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'WS1:messages' of XML schema type 'WS1:ArrayOf_xsd_string'
        WS1__ArrayOf_USCORExsd_USCOREstring *messages;
        /// Required nillable (xsi:nil when NULL) element 'WS1:success' of XML schema type 'WS1:ArrayOf_xsd_boolean'
        WS1__ArrayOf_USCORExsd_USCOREboolean *success;
      public:
        /// Return unique type id SOAP_TYPE_WS1__CreateItemResp
        virtual long soap_type(void) const { return SOAP_TYPE_WS1__CreateItemResp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS1__CreateItemResp, default initialized and not managed by a soap context
        virtual WS1__CreateItemResp *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS1__CreateItemResp); }
      public:
        /// Constructor with default initializations
        WS1__CreateItemResp() : messages(), success() { }
        virtual ~WS1__CreateItemResp() { }
        /// Friend allocator used by soap_new_WS1__CreateItemResp(struct soap*, int)
        friend SOAP_FMAC1 WS1__CreateItemResp * SOAP_FMAC2 KProcessService_instantiate_WS1__CreateItemResp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:209 */
#ifndef SOAP_TYPE__WS1__getFile
#define SOAP_TYPE__WS1__getFile (26)
/* complex XML schema type 'WS1:getFile': */
class SOAP_CMAC _WS1__getFile {
      public:
        /// Required element 'WS1:id' of XML schema type 'xsd:string'
        std::string id;
        /// Required element 'WS1:fileName' of XML schema type 'xsd:string'
        std::string fileName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getFile
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getFile, default initialized and not managed by a soap context
        virtual _WS1__getFile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getFile); }
      public:
        /// Constructor with default initializations
        _WS1__getFile() : id(), fileName(), soap() { }
        virtual ~_WS1__getFile() { }
        /// Friend allocator used by soap_new__WS1__getFile(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getFile * SOAP_FMAC2 KProcessService_instantiate__WS1__getFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:211 */
#ifndef SOAP_TYPE__WS1__getFileResponse
#define SOAP_TYPE__WS1__getFileResponse (27)
/* complex XML schema type 'WS1:getFileResponse': */
class SOAP_CMAC _WS1__getFileResponse {
      public:
        /// Required element 'WS1:getFileReturn' of XML schema type 'WS1:GetFileResp'
        WS1__GetFileResp *getFileReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__getFileResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__getFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__getFileResponse, default initialized and not managed by a soap context
        virtual _WS1__getFileResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__getFileResponse); }
      public:
        /// Constructor with default initializations
        _WS1__getFileResponse() : getFileReturn(), soap() { }
        virtual ~_WS1__getFileResponse() { }
        /// Friend allocator used by soap_new__WS1__getFileResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__getFileResponse * SOAP_FMAC2 KProcessService_instantiate__WS1__getFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:213 */
#ifndef SOAP_TYPE__WS1__importData
#define SOAP_TYPE__WS1__importData (28)
/* complex XML schema type 'WS1:importData': */
class SOAP_CMAC _WS1__importData {
      public:
        /// Required element 'WS1:id' of XML schema type 'xsd:string'
        std::string id;
        /// Required element 'WS1:xmlTemplate' of XML schema type 'xsd:string'
        std::string xmlTemplate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__importData
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__importData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__importData, default initialized and not managed by a soap context
        virtual _WS1__importData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__importData); }
      public:
        /// Constructor with default initializations
        _WS1__importData() : id(), xmlTemplate(), soap() { }
        virtual ~_WS1__importData() { }
        /// Friend allocator used by soap_new__WS1__importData(struct soap*, int)
        friend SOAP_FMAC1 _WS1__importData * SOAP_FMAC2 KProcessService_instantiate__WS1__importData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:215 */
#ifndef SOAP_TYPE__WS1__importDataResponse
#define SOAP_TYPE__WS1__importDataResponse (29)
/* complex XML schema type 'WS1:importDataResponse': */
class SOAP_CMAC _WS1__importDataResponse {
      public:
        /// Required element 'WS1:importDataReturn' of XML schema type 'xsd:string'
        std::string importDataReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__importDataResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__importDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__importDataResponse, default initialized and not managed by a soap context
        virtual _WS1__importDataResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__importDataResponse); }
      public:
        /// Constructor with default initializations
        _WS1__importDataResponse() : importDataReturn(), soap() { }
        virtual ~_WS1__importDataResponse() { }
        /// Friend allocator used by soap_new__WS1__importDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__importDataResponse * SOAP_FMAC2 KProcessService_instantiate__WS1__importDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:217 */
#ifndef SOAP_TYPE__WS1__hello
#define SOAP_TYPE__WS1__hello (30)
/* complex XML schema type 'WS1:hello': */
class SOAP_CMAC _WS1__hello {
      public:
        /// Required element 'WS1:id' of XML schema type 'xsd:string'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__hello
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__hello; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__hello, default initialized and not managed by a soap context
        virtual _WS1__hello *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__hello); }
      public:
        /// Constructor with default initializations
        _WS1__hello() : id(), soap() { }
        virtual ~_WS1__hello() { }
        /// Friend allocator used by soap_new__WS1__hello(struct soap*, int)
        friend SOAP_FMAC1 _WS1__hello * SOAP_FMAC2 KProcessService_instantiate__WS1__hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:219 */
#ifndef SOAP_TYPE__WS1__helloResponse
#define SOAP_TYPE__WS1__helloResponse (31)
/* complex XML schema type 'WS1:helloResponse': */
class SOAP_CMAC _WS1__helloResponse {
      public:
        /// Required element 'WS1:helloReturn' of XML schema type 'xsd:string'
        std::string helloReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__helloResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__helloResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__helloResponse, default initialized and not managed by a soap context
        virtual _WS1__helloResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__helloResponse); }
      public:
        /// Constructor with default initializations
        _WS1__helloResponse() : helloReturn(), soap() { }
        virtual ~_WS1__helloResponse() { }
        /// Friend allocator used by soap_new__WS1__helloResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__helloResponse * SOAP_FMAC2 KProcessService_instantiate__WS1__helloResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:221 */
#ifndef SOAP_TYPE__WS1__createItems
#define SOAP_TYPE__WS1__createItems (32)
/* complex XML schema type 'WS1:createItems': */
class SOAP_CMAC _WS1__createItems {
      public:
        /// Required element 'WS1:createItemInfos' of XML schema type 'WS1:CreateItemInfo'
        std::vector<WS1__CreateItemInfo *> createItemInfos;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__createItems
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__createItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__createItems, default initialized and not managed by a soap context
        virtual _WS1__createItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__createItems); }
      public:
        /// Constructor with default initializations
        _WS1__createItems() : createItemInfos(), soap() { }
        virtual ~_WS1__createItems() { }
        /// Friend allocator used by soap_new__WS1__createItems(struct soap*, int)
        friend SOAP_FMAC1 _WS1__createItems * SOAP_FMAC2 KProcessService_instantiate__WS1__createItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:223 */
#ifndef SOAP_TYPE__WS1__createItemsResponse
#define SOAP_TYPE__WS1__createItemsResponse (33)
/* complex XML schema type 'WS1:createItemsResponse': */
class SOAP_CMAC _WS1__createItemsResponse {
      public:
        /// Required element 'WS1:createItemsReturn' of XML schema type 'WS1:CreateItemResp'
        WS1__CreateItemResp *createItemsReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__WS1__createItemsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__WS1__createItemsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _WS1__createItemsResponse, default initialized and not managed by a soap context
        virtual _WS1__createItemsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_WS1__createItemsResponse); }
      public:
        /// Constructor with default initializations
        _WS1__createItemsResponse() : createItemsReturn(), soap() { }
        virtual ~_WS1__createItemsResponse() { }
        /// Friend allocator used by soap_new__WS1__createItemsResponse(struct soap*, int)
        friend SOAP_FMAC1 _WS1__createItemsResponse * SOAP_FMAC2 KProcessService_instantiate__WS1__createItemsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:225 */
#ifndef SOAP_TYPE_WS2__mapItem
#define SOAP_TYPE_WS2__mapItem (34)
/* Type WS2__mapItem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS2:mapItem': */
class SOAP_CMAC WS2__mapItem : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'WS2:key' of XML schema type 'xsd:anyType'
        xsd__anyType *key;
        /// Required nillable (xsi:nil when NULL) element 'WS2:value' of XML schema type 'xsd:anyType'
        xsd__anyType *value;
      public:
        /// Return unique type id SOAP_TYPE_WS2__mapItem
        virtual long soap_type(void) const { return SOAP_TYPE_WS2__mapItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS2__mapItem, default initialized and not managed by a soap context
        virtual WS2__mapItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS2__mapItem); }
      public:
        /// Constructor with default initializations
        WS2__mapItem() : key(), value() { }
        virtual ~WS2__mapItem() { }
        /// Friend allocator used by soap_new_WS2__mapItem(struct soap*, int)
        friend SOAP_FMAC1 WS2__mapItem * SOAP_FMAC2 KProcessService_instantiate_WS2__mapItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:227 */
#ifndef SOAP_TYPE_WS2__Map
#define SOAP_TYPE_WS2__Map (35)
/* Type WS2__Map is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'WS2:Map': */
class SOAP_CMAC WS2__Map : public xsd__anyType {
      public:
        /// Optional element 'WS2:item' of XML schema type 'WS2:mapItem'
        std::vector<WS2__mapItem *> item;
      public:
        /// Return unique type id SOAP_TYPE_WS2__Map
        virtual long soap_type(void) const { return SOAP_TYPE_WS2__Map; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type WS2__Map, default initialized and not managed by a soap context
        virtual WS2__Map *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(WS2__Map); }
      public:
        /// Constructor with default initializations
        WS2__Map() : item() { }
        virtual ~WS2__Map() { }
        /// Friend allocator used by soap_new_WS2__Map(struct soap*, int)
        friend SOAP_FMAC1 WS2__Map * SOAP_FMAC2 KProcessService_instantiate_WS2__Map(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:807 */
#ifndef SOAP_TYPE___WS1__getFile
#define SOAP_TYPE___WS1__getFile (56)
/* Wrapper: */
struct SOAP_CMAC __WS1__getFile {
      public:
        /** Optional element 'WS1:getFile' of XML schema type 'WS1:getFile' */
        _WS1__getFile *WS1__getFile;
      public:
        /** Return unique type id SOAP_TYPE___WS1__getFile */
        long soap_type() const { return SOAP_TYPE___WS1__getFile; }
        /** Constructor with member initializations */
        __WS1__getFile() : WS1__getFile() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__getFile * SOAP_FMAC2 KProcessService_instantiate___WS1__getFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:874 */
#ifndef SOAP_TYPE___WS1__importData
#define SOAP_TYPE___WS1__importData (60)
/* Wrapper: */
struct SOAP_CMAC __WS1__importData {
      public:
        /** Optional element 'WS1:importData' of XML schema type 'WS1:importData' */
        _WS1__importData *WS1__importData;
      public:
        /** Return unique type id SOAP_TYPE___WS1__importData */
        long soap_type() const { return SOAP_TYPE___WS1__importData; }
        /** Constructor with member initializations */
        __WS1__importData() : WS1__importData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__importData * SOAP_FMAC2 KProcessService_instantiate___WS1__importData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:941 */
#ifndef SOAP_TYPE___WS1__hello
#define SOAP_TYPE___WS1__hello (64)
/* Wrapper: */
struct SOAP_CMAC __WS1__hello {
      public:
        /** Optional element 'WS1:hello' of XML schema type 'WS1:hello' */
        _WS1__hello *WS1__hello;
      public:
        /** Return unique type id SOAP_TYPE___WS1__hello */
        long soap_type() const { return SOAP_TYPE___WS1__hello; }
        /** Constructor with member initializations */
        __WS1__hello() : WS1__hello() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__hello * SOAP_FMAC2 KProcessService_instantiate___WS1__hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:1008 */
#ifndef SOAP_TYPE___WS1__createItems
#define SOAP_TYPE___WS1__createItems (68)
/* Wrapper: */
struct SOAP_CMAC __WS1__createItems {
      public:
        /** Optional element 'WS1:createItems' of XML schema type 'WS1:createItems' */
        _WS1__createItems *WS1__createItems;
      public:
        /** Return unique type id SOAP_TYPE___WS1__createItems */
        long soap_type() const { return SOAP_TYPE___WS1__createItems; }
        /** Constructor with member initializations */
        __WS1__createItems() : WS1__createItems() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __WS1__createItems * SOAP_FMAC2 KProcessService_instantiate___WS1__createItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\KProcessService.h:1195 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 KProcessService_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\KProcessService.h:1195 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 KProcessService_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\KProcessService.h:1195 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 KProcessService_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\KProcessService.h:1195 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 KProcessService_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\KProcessService.h:1195 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 KProcessService_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (12)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (11)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (16)
#endif

/* WS2__Map has binding name 'WS2__Map' for type 'WS2:Map' */
#ifndef SOAP_TYPE_WS2__Map
#define SOAP_TYPE_WS2__Map (35)
#endif

/* WS2__mapItem has binding name 'WS2__mapItem' for type 'WS2:mapItem' */
#ifndef SOAP_TYPE_WS2__mapItem
#define SOAP_TYPE_WS2__mapItem (34)
#endif

/* _WS1__createItemsResponse has binding name '_WS1__createItemsResponse' for type '' */
#ifndef SOAP_TYPE__WS1__createItemsResponse
#define SOAP_TYPE__WS1__createItemsResponse (33)
#endif

/* _WS1__createItems has binding name '_WS1__createItems' for type '' */
#ifndef SOAP_TYPE__WS1__createItems
#define SOAP_TYPE__WS1__createItems (32)
#endif

/* _WS1__helloResponse has binding name '_WS1__helloResponse' for type '' */
#ifndef SOAP_TYPE__WS1__helloResponse
#define SOAP_TYPE__WS1__helloResponse (31)
#endif

/* _WS1__hello has binding name '_WS1__hello' for type '' */
#ifndef SOAP_TYPE__WS1__hello
#define SOAP_TYPE__WS1__hello (30)
#endif

/* _WS1__importDataResponse has binding name '_WS1__importDataResponse' for type '' */
#ifndef SOAP_TYPE__WS1__importDataResponse
#define SOAP_TYPE__WS1__importDataResponse (29)
#endif

/* _WS1__importData has binding name '_WS1__importData' for type '' */
#ifndef SOAP_TYPE__WS1__importData
#define SOAP_TYPE__WS1__importData (28)
#endif

/* _WS1__getFileResponse has binding name '_WS1__getFileResponse' for type '' */
#ifndef SOAP_TYPE__WS1__getFileResponse
#define SOAP_TYPE__WS1__getFileResponse (27)
#endif

/* _WS1__getFile has binding name '_WS1__getFile' for type '' */
#ifndef SOAP_TYPE__WS1__getFile
#define SOAP_TYPE__WS1__getFile (26)
#endif

/* WS1__CreateItemResp has binding name 'WS1__CreateItemResp' for type 'WS1:CreateItemResp' */
#ifndef SOAP_TYPE_WS1__CreateItemResp
#define SOAP_TYPE_WS1__CreateItemResp (25)
#endif

/* WS1__ArrayOf_USCORExsd_USCOREboolean has binding name 'WS1__ArrayOf_USCORExsd_USCOREboolean' for type 'WS1:ArrayOf_xsd_boolean' */
#ifndef SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean
#define SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREboolean (24)
#endif

/* WS1__ArrayOf_USCORExsd_USCOREstring has binding name 'WS1__ArrayOf_USCORExsd_USCOREstring' for type 'WS1:ArrayOf_xsd_string' */
#ifndef SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring
#define SOAP_TYPE_WS1__ArrayOf_USCORExsd_USCOREstring (23)
#endif

/* WS1__CreateItemInfo has binding name 'WS1__CreateItemInfo' for type 'WS1:CreateItemInfo' */
#ifndef SOAP_TYPE_WS1__CreateItemInfo
#define SOAP_TYPE_WS1__CreateItemInfo (22)
#endif

/* WS1__ArrayOfProperty has binding name 'WS1__ArrayOfProperty' for type 'WS1:ArrayOfProperty' */
#ifndef SOAP_TYPE_WS1__ArrayOfProperty
#define SOAP_TYPE_WS1__ArrayOfProperty (21)
#endif

/* WS1__Property has binding name 'WS1__Property' for type 'WS1:Property' */
#ifndef SOAP_TYPE_WS1__Property
#define SOAP_TYPE_WS1__Property (20)
#endif

/* WS1__GetFileResp has binding name 'WS1__GetFileResp' for type 'WS1:GetFileResp' */
#ifndef SOAP_TYPE_WS1__GetFileResp
#define SOAP_TYPE_WS1__GetFileResp (19)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (18)
#endif

/* xsd__string_ has binding name 'xsd__string_' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (17)
#endif

/* xsd__boolean_ has binding name 'xsd__boolean_' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (15)
#endif

/* xsd__base64Binary__ has binding name 'xsd__base64Binary__' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (14)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (78)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (77)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (71)
#endif

/* _WS1__createItems * has binding name 'PointerTo_WS1__createItems' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__createItems
#define SOAP_TYPE_PointerTo_WS1__createItems (65)
#endif

/* _WS1__hello * has binding name 'PointerTo_WS1__hello' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__hello
#define SOAP_TYPE_PointerTo_WS1__hello (61)
#endif

/* _WS1__importData * has binding name 'PointerTo_WS1__importData' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__importData
#define SOAP_TYPE_PointerTo_WS1__importData (57)
#endif

/* _WS1__getFile * has binding name 'PointerTo_WS1__getFile' for type '' */
#ifndef SOAP_TYPE_PointerTo_WS1__getFile
#define SOAP_TYPE_PointerTo_WS1__getFile (53)
#endif

/* WS2__mapItem * has binding name 'PointerToWS2__mapItem' for type 'WS2:mapItem' */
#ifndef SOAP_TYPE_PointerToWS2__mapItem
#define SOAP_TYPE_PointerToWS2__mapItem (51)
#endif

/* xsd__anyType * has binding name 'PointerToxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_PointerToxsd__anyType
#define SOAP_TYPE_PointerToxsd__anyType (50)
#endif

/* WS1__CreateItemResp * has binding name 'PointerToWS1__CreateItemResp' for type 'WS1:CreateItemResp' */
#ifndef SOAP_TYPE_PointerToWS1__CreateItemResp
#define SOAP_TYPE_PointerToWS1__CreateItemResp (49)
#endif

/* WS1__CreateItemInfo * has binding name 'PointerToWS1__CreateItemInfo' for type 'WS1:CreateItemInfo' */
#ifndef SOAP_TYPE_PointerToWS1__CreateItemInfo
#define SOAP_TYPE_PointerToWS1__CreateItemInfo (47)
#endif

/* WS1__GetFileResp * has binding name 'PointerToWS1__GetFileResp' for type 'WS1:GetFileResp' */
#ifndef SOAP_TYPE_PointerToWS1__GetFileResp
#define SOAP_TYPE_PointerToWS1__GetFileResp (46)
#endif

/* WS1__ArrayOf_USCORExsd_USCOREboolean * has binding name 'PointerToWS1__ArrayOf_USCORExsd_USCOREboolean' for type 'WS1:ArrayOf_xsd_boolean' */
#ifndef SOAP_TYPE_PointerToWS1__ArrayOf_USCORExsd_USCOREboolean
#define SOAP_TYPE_PointerToWS1__ArrayOf_USCORExsd_USCOREboolean (45)
#endif

/* WS1__ArrayOf_USCORExsd_USCOREstring * has binding name 'PointerToWS1__ArrayOf_USCORExsd_USCOREstring' for type 'WS1:ArrayOf_xsd_string' */
#ifndef SOAP_TYPE_PointerToWS1__ArrayOf_USCORExsd_USCOREstring
#define SOAP_TYPE_PointerToWS1__ArrayOf_USCORExsd_USCOREstring (44)
#endif

/* WS2__Map * has binding name 'PointerToWS2__Map' for type 'WS2:Map' */
#ifndef SOAP_TYPE_PointerToWS2__Map
#define SOAP_TYPE_PointerToWS2__Map (41)
#endif

/* WS1__ArrayOfProperty * has binding name 'PointerToWS1__ArrayOfProperty' for type 'WS1:ArrayOfProperty' */
#ifndef SOAP_TYPE_PointerToWS1__ArrayOfProperty
#define SOAP_TYPE_PointerToWS1__ArrayOfProperty (40)
#endif

/* WS1__Property * has binding name 'PointerToWS1__Property' for type 'WS1:Property' */
#ifndef SOAP_TYPE_PointerToWS1__Property
#define SOAP_TYPE_PointerToWS1__Property (38)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (37)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (36)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (13)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<WS2__mapItem *>  has binding name 'std__vectorTemplateOfPointerToWS2__mapItem' for type 'WS2:mapItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToWS2__mapItem
#define SOAP_TYPE_std__vectorTemplateOfPointerToWS2__mapItem (52)
#endif

/* std::vector<WS1__CreateItemInfo *>  has binding name 'std__vectorTemplateOfPointerToWS1__CreateItemInfo' for type 'WS1:CreateItemInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToWS1__CreateItemInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerToWS1__CreateItemInfo (48)
#endif

/* std::vector<bool>  has binding name 'std__vectorTemplateOfbool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_std__vectorTemplateOfbool
#define SOAP_TYPE_std__vectorTemplateOfbool (43)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (42)
#endif

/* std::vector<WS1__Property *>  has binding name 'std__vectorTemplateOfPointerToWS1__Property' for type 'WS1:Property' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToWS1__Property
#define SOAP_TYPE_std__vectorTemplateOfPointerToWS1__Property (39)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    
    /** Web service synchronous operation 'soap_call___WS1__getFile' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___WS1__getFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__getFile *WS1__getFile, _WS1__getFileResponse &WS1__getFileResponse);
    /** Web service asynchronous operation 'soap_send___WS1__getFile' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___WS1__getFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__getFile *WS1__getFile);
    /** Web service asynchronous operation 'soap_recv___WS1__getFile' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___WS1__getFile(struct soap *soap, _WS1__getFileResponse &WS1__getFileResponse);
    
    /** Web service synchronous operation 'soap_call___WS1__importData' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___WS1__importData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__importData *WS1__importData, _WS1__importDataResponse &WS1__importDataResponse);
    /** Web service asynchronous operation 'soap_send___WS1__importData' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___WS1__importData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__importData *WS1__importData);
    /** Web service asynchronous operation 'soap_recv___WS1__importData' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___WS1__importData(struct soap *soap, _WS1__importDataResponse &WS1__importDataResponse);
    
    /** Web service synchronous operation 'soap_call___WS1__hello' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___WS1__hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__hello *WS1__hello, _WS1__helloResponse &WS1__helloResponse);
    /** Web service asynchronous operation 'soap_send___WS1__hello' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___WS1__hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__hello *WS1__hello);
    /** Web service asynchronous operation 'soap_recv___WS1__hello' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___WS1__hello(struct soap *soap, _WS1__helloResponse &WS1__helloResponse);
    
    /** Web service synchronous operation 'soap_call___WS1__createItems' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___WS1__createItems(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__createItems *WS1__createItems, _WS1__createItemsResponse &WS1__createItemsResponse);
    /** Web service asynchronous operation 'soap_send___WS1__createItems' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___WS1__createItems(struct soap *soap, const char *soap_endpoint, const char *soap_action, _WS1__createItems *WS1__createItems);
    /** Web service asynchronous operation 'soap_recv___WS1__createItems' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___WS1__createItems(struct soap *soap, _WS1__createItemsResponse &WS1__createItemsResponse);

#endif

/* End of KProcessServiceStub.h */
